import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/notification_model.dart';

class NotificationService {
  static const String _notificationsCollection = 'notifications';
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Get notifications for current user
  Stream<List<NotificationModel>> getNotificationsStream(String userId) {
    return _firestore
        .collection(_notificationsCollection)
        .where('userId', isEqualTo: userId)
        .orderBy('createdAt', descending: true)
        .limit(50) // Limit to latest 50 notifications
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => NotificationModel.fromDoc(doc))
            .toList());
  }

  // Create a notification
  Future<void> createNotification({
    required String userId,
    required String senderUserId,
    required String senderUsername,
    required String senderProfileImageUrl,
    required NotificationType type,
    required String title,
    required String message,
    String? postId,
    String? chatId,
    bool isFollowBack = false,
  }) async {
    try {
      // Don't create notification for own actions
      if (userId == senderUserId) return;

      final notification = NotificationModel(
        id: '', // Will be auto-generated by Firestore
        userId: userId,
        senderUserId: senderUserId,
        senderUsername: senderUsername,
        senderProfileImageUrl: senderProfileImageUrl,
        type: type,
        title: title,
        message: message,
        createdAt: DateTime.now(),
        isRead: false,
        postId: postId,
        chatId: chatId,
        isFollowBack: isFollowBack,
      );

      await _firestore
          .collection(_notificationsCollection)
          .add(notification.toMap());
    } catch (e) {
      print('Error creating notification: $e');
      throw Exception('Failed to create notification');
    }
  }

  // Mark notification as read
  Future<void> markAsRead(String notificationId) async {
    try {
      await _firestore
          .collection(_notificationsCollection)
          .doc(notificationId)
          .update({'isRead': true});
    } catch (e) {
      print('Error marking notification as read: $e');
    }
  }

  // Mark all notifications as read for a user
  Future<void> markAllAsRead(String userId) async {
    try {
      final query = await _firestore
          .collection(_notificationsCollection)
          .where('userId', isEqualTo: userId)
          .where('isRead', isEqualTo: false)
          .get();

      final batch = _firestore.batch();
      for (final doc in query.docs) {
        batch.update(doc.reference, {'isRead': true});
      }
      await batch.commit();
    } catch (e) {
      print('Error marking all notifications as read: $e');
    }
  }

  // Get unread notification count
  Stream<int> getUnreadCount(String userId) {
    return _firestore
        .collection(_notificationsCollection)
        .where('userId', isEqualTo: userId)
        .where('isRead', isEqualTo: false)
        .snapshots()
        .map((snapshot) => snapshot.docs.length);
  }

  // Delete notification
  Future<void> deleteNotification(String notificationId) async {
    try {
      await _firestore
          .collection(_notificationsCollection)
          .doc(notificationId)
          .delete();
    } catch (e) {
      print('Error deleting notification: $e');
    }
  }

  // Helper methods for creating specific types of notifications

  Future<void> createLikeNotification({
    required String postOwnerId,
    required String likerUserId,
    required String likerUsername,
    required String likerProfileImageUrl,
    required String postId,
  }) async {
    await createNotification(
      userId: postOwnerId,
      senderUserId: likerUserId,
      senderUsername: likerUsername,
      senderProfileImageUrl: likerProfileImageUrl,
      type: NotificationType.like,
      title: 'New Like',
      message: '$likerUsername liked your post',
      postId: postId,
    );
  }

  Future<void> createCommentNotification({
    required String postOwnerId,
    required String commenterUserId,
    required String commenterUsername,
    required String commenterProfileImageUrl,
    required String postId,
    required String commentText,
  }) async {
    final message = commentText.length > 50
        ? '${commentText.substring(0, 50)}...'
        : commentText;

    await createNotification(
      userId: postOwnerId,
      senderUserId: commenterUserId,
      senderUsername: commenterUsername,
      senderProfileImageUrl: commenterProfileImageUrl,
      type: NotificationType.comment,
      title: 'New Comment',
      message: '$commenterUsername commented: "$message"',
      postId: postId,
    );
  }

  Future<void> createFollowNotification({
    required String followedUserId,
    required String followerUserId,
    required String followerUsername,
    required String followerProfileImageUrl,
    required bool isFollowBack,
  }) async {
    await createNotification(
      userId: followedUserId,
      senderUserId: followerUserId,
      senderUsername: followerUsername,
      senderProfileImageUrl: followerProfileImageUrl,
      type: NotificationType.follow,
      title: 'New Follower',
      message: '$followerUsername started following you',
      isFollowBack: isFollowBack,
    );
  }

  Future<void> createMessageNotification({
    required String receiverUserId,
    required String senderUserId,
    required String senderUsername,
    required String senderProfileImageUrl,
    required String chatId,
    required String messagePreview,
  }) async {
    await createNotification(
      userId: receiverUserId,
      senderUserId: senderUserId,
      senderUsername: senderUsername,
      senderProfileImageUrl: senderProfileImageUrl,
      type: NotificationType.message,
      title: 'New Message',
      message: 'You have a new message from $senderUsername',
      chatId: chatId,
    );
  }
}
